.LC0:
        .long 0x0
.LC1:
.LC2:
        .long 0x40800000
algorithm:
        pushl %ebp          // сохраняем текущее значение регистра ebp в стек
        movl %esp,%ebp      // копируем значение регистра esp в ebp (создание нового стекового кадра)
        subl $28,%esp       // выделяем место под локальные переменные
        pushl %ebx          // добавляем в стек регистр ebx
        pushl %esi          // добавляем в стек регистр esi
        pushl .LC0          // добавляем в стек 0
        popl -4(%ebp)       // достаем 0 из стека в res (теперь вершина стека - esi)
        movl $0,-8(%ebp)    // сохраняем 0 в i
.L2:
        movl 8(%ebp),%eax   // в eax сохраняем параметр n
        cmpl -8(%ebp),%eax  // сравниваем i и n
        jl .L3              // условные переход к метке .L3 если при сравнении i > n
        fildl -8(%ebp)      // конвертирует i из int в double-extended precision floating-point и добавляет это значение в сопроцессор (st(0)) (в сопроцессоре есть свой стек для операций с вещественными числами, по умолчанию это операции со st(0) и st(1))
        fstpl -28(%ebp)     // выталкивает значение из st(0) в ebp - 28 (7 переменная в стеке)
        pushl -24(%ebp)     // добавляет в стек значение из ebp - 24
        pushl -28(%ebp)     // добавляет в стек значение из ebp - 28      вроде как эти два pusha - превращение float в double, c обратным порядком байтов почему-то
        pushl .LC1+4        // добавляет в стек что-то
        pushl .LC1          // добавляет в стек что-то       вроде это добавление в стек -1 в виде double
        call pow            // вызывает pow
        addl $-8,%esp       // освобождает место для результата
        fstpl (%esp)        // загружает результат в esp (вершина стека) (8 байт)
        popl %ebx           // выталкивает вершину стека (4 байта) в ebx
        popl %esi           // выталкивает вершину стека в esi
        pushl %esi          // пушит их обратно хз зачем было выталкивать
        pushl %ebx
        fldl (%esp)         // помещаем в стек сопроцессора вершину стека (8 байт) - (по идее p)
        addl $8,%esp        // сдвигаем стек вправо на 8 байт
        fstps -12(%ebp)     // выталкиваем из стека сопроцессора в 3 - ю переменную от ebp
        movl -8(%ebp),%ebx  // сохраняем в ebx i
        sall $1,%ebx        // умножаем ebx на 2 (на самом деле сдвиг вправо) (i * 2)
        movl %ebx,%eax      // сохраняет i из ebx в eax
        incl %eax           // здесь хранится конечное значение tmp
        movl %eax,-16(%ebp) // из eax в 4 переменную (переносим туда tmp)
        fildl -16(%ebp)     // конвертирует tmp из int в double-extended precision floating-point и добавляет это значение в сопроцессор (st(0))
        addl $-4,%esp       // выделяем место для новой переменной
        fsts (%esp)         // копируем из стека сопроцессора в вершину стека
        popl %ebx           // сохраняем в регистр ebx вершину стека из снимаем переменную со стека
        fdivrs -12(%ebp)    // обратное деление и сохранение результата в 3 переменную
        fstps -20(%ebp)     // выталкивание из стека сопроцессора в 5-ю переменную
        flds -4(%ebp)       // помещаем в стек сопроцессора res
        fadds -20(%ebp)     // прибавляем к res d
        fstps -4(%ebp)      // выталкиваем из стека сопроцессора в res
        leal 16(%esp),%esp  // вычисляет адрес esp + 16 и помещает в esp
        incl -8(%ebp)       // i++ - шаг итерации
        jmp .L2             // переход к началу for
.L3:
        flds -4(%ebp)       // помещает в стек сопроцессора res
        fmuls .LC2          // умножает на 4
        addl $-4,%esp       // выделение памяти на стеке (4 байт)
        fstps (%esp)        // выталкивает из стека сопроцессора в вершину стека
        popl %ebx           // сохраняет в ebx вершину стека, удаляет ее
        pushl %ebx          // добавляет в вершину значение ebx (зачем было удалять?)
        flds (%esp)         // помещает в стек сопроцессора esp - конечный результат переменной res
        addl $4,%esp        // сдвигает стек вправо
        jmp .L1
.L1:
        leal -36(%ebp),%esp     // вычисляет адрес ebp - 36 и сохраняет в esp
        popl %esi               // выталкивает вершину стека и сохраняет в esi
        popl %ebx               // выталкивает вершину стека и сохраняет в ebx
        leave                   // чистим стековый кадр до прежнего состояния (эквивалентно movl %ebp, %esp;  popl %ebp)
        ret                     // возврат из функции
.LC3:
        .byte 0x25,0x66,0x0
main:
        pushl %ebp          // Сохраняем указатель кадра вызвавшей программы (текущее значение регистра ebp  стек)
        movl %esp,%ebp      // копируем значение регистра esp в ebp (создание нового стекового кадра)
        subl $8,%esp        // выделяем память под две переменные (n, res)
        movl $10000,-4(%ebp) // сохраняем в n 10000
        pushl -4(%ebp)      // добавляем в стек n - параметр функции
        call algorithm      // вызываем функцию (помещаем адрес возврата в стек, передаем управление функции)
        fstps -8(%ebp)      // загружаем результат из st(0) в res
        flds -8(%ebp)       // помещаем в стек сопроцессора (st(0)) res
        subl $8,%esp        // выделяем 8 байт в стеке
        fstpl (%esp)        // Записываем в выделенное место значение из st(0)
        pushl $.LC3         // добавляем в стек данные (видимо "%f")
        call printf         // вызываем printf
        leave               // чистим стековый кадр до прежнего состояния (эквивалентно movl %ebp, %esp;  popl %ebp)
        ret                 // возврат из функции